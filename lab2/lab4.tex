\documentclass[12pt]{article}

\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{minted}

\usepackage{color} %% это для отображения цвета в коде
\usepackage{listings} %% собственно, это и есть пакет listings

\lstset{ %
language=C++,                 % выбор языка для подсветки (здесь это С++)
basicstyle=\small\sffamily, % размер и начертание шрифта для подсветки кода
numbers=left,               % где поставить нумерацию строк (слева\справа)
%numberstyle=\tiny,           % размер шрифта для номеров строк
stepnumber=1,                   % размер шага между двумя номерами строк
numbersep=5pt,                % как далеко отстоят номера строк от подсвечиваемого кода
backgroundcolor=\color{white}, % цвет фона подсветки - используем \usepackage{color}
showspaces=false,            % показывать или нет пробелы специальными отступами
showstringspaces=false,      % показывать или нет пробелы в строках
showtabs=false,             % показывать или нет табуляцию в строках
frame=single,              % рисовать рамку вокруг кода
tabsize=2,                 % размер табуляции по умолчанию равен 2 пробелам
captionpos=t,              % позиция заголовка вверху [t] или внизу [b] 
breaklines=true,           % автоматически переносить строки (да\нет)
breakatwhitespace=false, % переносить строки только если есть пробел
escapeinside={\%*}{*)}   % если нужно добавить комментарии в коде
}


\begin{document}
\begin{titlepage}
\begin{center}
\textbf{МИНИСТЕРСТВО ОБРАЗОВАНИЯ И НАУКИ РОССИЙСКОЙ ФЕДЕРАЦИИ
\medskip
МОСКОВСКИЙ АВИАЦИОННЫЙ ИНСТИТУТ
(НАЦИОНАЛЬНЫЙ ИССЛЕДОВАТЕЛЬСКИЙ УНИВЕРСТИТЕТ)
\vfill\vfill
{\Huge ЛАБОРАТОРНАЯ РАБОТА №4} \\
по курсу объектно-ориентированное программирование
I семестр, 2021/22 уч. год}
\end{center}
\vfill

Студент \uline{\it {Ханнанов Руслан Маратович, группа М8О-208Б-20}\hfill}

Преподаватель \uline{\it {Дорохов Евгений Павлович}\hfill}

\vfill
\end{titlepage}

\subsection*{Условие}

Задание: \
Вариант 22: N-дерево.\
Необходимо спроектировать и запрограммировать на языке C++ класс-контейнер первого уровня, содержащий одну фигуру ( колонка фигура 1), согласно вариантам задания. Классы должны удовлетворять следующим правилам:
\begin{enumerate}
\item Требования к классу фигуры аналогичны требованиям из лабораторной работы №1.
\item Классы фигур должны содержать набор следующих методов:
\begin{itemsize}
\begin{enumerate}
    \item[*] Перегруженный оператор ввода координат вершин фигуры из потока std::istream (>>). Он должен заменить конструктор, принимающий координаты вершин из стандартного потока.
    \item[*] Перегруженный оператор вывода в поток std::ostream (<<), заменяющий метод Print из лабораторной работы 1. 
    \item[*] Оператор копирования (=)
    \item[*] Оператор сравнения с такими же фигурами (==)
\end{enumerate}
\end{itemsize}
\item Класс-контейнер должен соджержать объекты фигур “по значению” (не по ссылке).
\item Класс-контейнер должен содержать набор следующих методов:
\begin{itemsize}
\begin{enumerate}

    \item[*] InsertFirst() – метод, добавляющий элемент в начало списка
    \item[*] InsertLast() – метод, добавляющий фигуру в конец списка
    \item[*] Insert() - метод, добавляющий фигуру в произвольное место списка
    \item[*] RemoveFirst() - метод, удаляющий первый элемент списка
    \item[*] RemoveLast() - метод, удаляющий последний элемент списка
    \item[*] Remove() - метод, удаляющий произвольный элемент списка
    \item[*] Empty() - метод, проверяющий пустоту списка
    \item[*] Length() - метод, возвращающий длину массива
    \item[*] operator<< – выводит связанный список в соответствии с заданным форматом в поток вывода
    \item[*] Clear() - метод, удаляющий все элементы контейнера, но позволяющий пользоваться им.
\end{enumerate}
\end{itemsize}
\end{enumerate}
\\ \\
Нельзя использовать:
\begin{enumerate}
\item Стандартные контейнеры std.
\item Шаблоны (template).
\item Различные варианты умных указателей (shared\_ptr, weak\_ptr).
\end{enumerate}
\\ \\
Программа должна позволять:
\begin{enumerate}
\item Вводить произвольное количество фигур и добавлять их в контейнер.
\item Распечатывать содержимое контейнера.
\item Удалять фигуры из контейнера.
\end{enumerate}

\subsection*{Описание программы}

Исходный код лежит в 10 файлах:
\begin{enumerate}
\item src/main.cpp: основная программа, взаимодействие с пользователем посредством комманд из меню

\item include/figure.h:    описание абстрактного класса фигур

\item include/point.h:     описание класса точки
\item include/node.h:  описание класса ноды дерева
\item include/pentagon.h: описание класса пятиугольника, наследующегося от figures
\item include/tnary\_tree.h:    описание класса N-дерева

\item include/point.cpp:     реализация класса точки
\item include/pentagon.cpp:  реализация класса пятиугольника, наследующегося от figures
\item include/node.cpp: реализация класса ноды дерева
\item include/tnary\_tree.cpp:    реализация класса N-дерева

\end{enumerate}

\subsection*{Протокол работы}
Tree is not empty \\
Pentagon:(0, 0) (0, 2) (1, 3) (2, 3) (3, 0) \\
Pentagon:(0, 0) (0, 3) (1, 3) (2, 3) (3, 0) \\
Pentagon:(0, 0) (0, 8) (1, 3) (2, 3) (3, 0) \\
Pentagon:(0, 0) (0, 4) (1, 3) (2, 3) (3, 0) \\
Pentagon:(0, 0) (0, 6) (1, 3) (2, 3) (3, 0) \\
 \\
Pentagon:(0, 0) (0, 0) (0, 0) (0, 0) (0, 0) \\
Pentagon:(0, 0) (0, 3) (1, 3) (2, 3) (3, 0) \\
Pentagon:(0, 0) (0, 8) (1, 3) (2, 3) (3, 0) \\
Pentagon:(0, 0) (0, 4) (1, 3) (2, 3) (3, 0) \\
 \\
Pentagon:(0, 0) (0, 0) (0, 0) (0, 0) (0, 0) \\
Pentagon:(0, 0) (0, 3) (1, 3) (2, 3) (3, 0) \\
Pentagon:(0, 0) (0, 8) (1, 3) (2, 3) (3, 0) \\
Pentagon:(0, 0) (0, 4) (1, 3) (2, 3) (3, 0) \\
Pentagon:(0, 0) (0, 6) (1, 3) (2, 3) (3, 0) \\
34.5 \\
 \\
Pentagon:(0, 0) (0, 0) (0, 0) (0, 0) (0, 0) \\
Pentagon:(0, 0) (0, 3) (1, 3) (2, 3) (3, 0) \\
Pentagon:(0, 0) (0, 8) (1, 3) (2, 3) (3, 0) \\
Pentagon:(0, 0) (0, 4) (1, 3) (2, 3) (3, 0) \\
Pentagon:(0, 0) (0, 6) (1, 3) (2, 3) (3, 0) \\
 \\
0: [7.5: [10], 8, 9] \\

\subsection*{Дневник отладки}
Было непонятно, каким именно образом реализовывать добавление элемента в дерево, то есть по какому принципу, но после выбора ввода точного пути - реализовать получилось достаточно быстро.

\subsection*{Недочёты}
Недочетов не заметил

\subsection*{Выводы}
В процессе выполнения данной лабораторной работы я реализовал класс-контейнер N-дерево и методы работы с ним. Также мной было применено динамическое выделение памяти с помощью операторов new и delete.


\vfill

\subsection*{Исходный код:}

{\Huge figure.h}
\inputminted
    {C++}{figure.h}
    
{\Huge point.h}
\inputminted
    {C++}{point.h}
    
{\Huge point.cpp}
\inputminted
    {C++}{point.cpp}

{\Huge pentagon.h}
\inputminted
    {C++}{pentagon.h}
    
{\Huge pentagon.cpp}
\inputminted
    {C++}{pentagon.cpp}

{\Huge node.h}
\inputminted
    {C++}{node.h}
    
{\Huge node.cpp}
\inputminted
    {C++}{node.cpp}

{\Huge tnary\_tree.h}
\inputminted
    {C++}{tnary_tree.h}
    
{\Huge tnary\_tree.cpp}
\inputminted
    {C++}{tnary_tree.cpp}

{\Huge main.cpp}
\inputminted
    {C++}{main.cpp}
    \pagebreak
    
\end{document}